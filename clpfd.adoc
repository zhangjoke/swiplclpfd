CLP(FD) 有限域上的约束逻辑程序设计
=====================
Anne Ogborn <annie66us@yahoo.com>
:Author Initials: AO
:toc2:
:icons:
:numbered:
:website: http://www.pathwayslms.com/swipltuts/
:theme: pathways

link:/swipltuts/index.html[Up to All Tutorials]

关于本教程
-----

谁应该使用本教程
~~~~~~~~

本教程适用于想要使用clp(fd)，且有一定经验的SWI-Prolog程序员。

此外，对于那些使用其他版本Prolog，且想要用clp(fd)的Prolog程序员，本教程也是有用的。

本教程的重点**不**在理论。作者不是数学家，而且本文可能对那些能利用学术文献找到材料的称职的数学家也没多少用处。

本教程将帮助你理解有限域上的约束系统的基础知识。

它还含有一些__实践经验__。 

这篇教程主要旨在用更平易近人的语言把简洁、充满数学语言的SWI-Prolog的clp(fd)谓词文档转述出来。

clp(fd)有什么用？
~~~~~~~~~~~~

clp(fd)是标准SWI-Prolog发行版中包含的一个库。它可以解决变量之间满足一定关系的多个变量的问题。 

image::images/Robert_Wadlow.jpg["罗伯特·瓦德罗，以108英寸的身高成为世界上已知的最高的人", float="left"]
clp(fd)还可用于替代面向对象语言中由getter和setter提供的许多保护函数。例如，如果我们尚不知道一个人的实际身高，但我们仍然可以肯定他的身高会超过21英寸，但不会高于108英寸（已知的最矮/最高身高）。
当我们最终求得一个解时，不合理的值将被丢弃。

clp(fd)可以通过减少搜索空间来优化搜索问题。约束条件可以削减搜索空间中的整个子树。

在解决各种'求得变量值'的问题时，clp(fd)非常有用。这是一些clp(fd)可以解决的问题的大类：

 *  通过将变量约束在合理范围内确保程序的正确性
 * 调度问题，例如，'应该在什么时候做什么工作来生产这些产品？'
 * 优化问题，例如，'为了实现利润最大化，我们应该在这家工厂生产什么产品组合？'
 * 需求满足问题，例如寻找医院中符合条件的房间，比如在康复室旁的手术室，或是规划全家都赞成的度假方案。
 * 排序问题，例如规划我们前往目的地的路线。
 * 标注问题，例如数独或密码算术问题。
 * 信任与意图问题，例如侦探谜题和游戏中的非玩家角色。
 * 分配问题，例如寻求一个分配飞机机组人员的方案，使其满足工会的最大时间出勤的要求。
 * 为涉及多个相关联的变量的问题寻求令人满意的解，例如有一群互相猜忌的少女要参加聚会，其中，如果B要去，A才会去；如果C要去，B就不会去，等等，需要算出谁会去参加聚会。
 * 为多个互相影响的变量创建可接受的方案列表。例如，一个宴席筹备者可能希望给出的宴席菜单能满足预算、厨师和侍者的日程、烤箱的安排等不同需求，然后自己选择采用哪个方案。
 * 图形的几何约束条件，例如，在一个CAD系统中，要求其中两条线必须垂直，另外两条必须平行，其他两条线相距30英寸，诸如此类。

.clp(fd)的运用练习
*************************

给上面的各个类别再举一个例子。 

尽量扩展问题的范围。 

例如，我们通常认为排序是时间上的先后顺序，但它也可能是其他维度上的顺序。
给定一组火车车厢，按合理的顺序排列它们，并遵守一些规则，比如，油罐车不得靠近引擎，守车必须在后面，这就是一个排序问题。

如果你在这个问题上有困难，也别担心——可以先放一边。

************************* 

前提
~~

掌握SWI-Prolog的基础知识。

数学水平与计算机科学本科课程的高等水平相当。

SWI-Prolog已安装并运行正常。

本教程没有附带代码文件。你可以剪贴示例代码。

你可以从本教程中学到什么
~~~~~~~~~~~~

如果你读完此教程，并完成所有练习，预计能够：

 * 了解约束编程的基本概念。
 * 能编写求得未知值的解的程序。
 * 能用clp(fd)库表述实世界中的问题。
 * 能对约束系统问题选用适当的解决方案。
 * 了解如何在实际的SWI-Prolog的程序中使用clp(fd)。

完成时间
~~~~

6-8小时，因人的数学水平而异。

CLP(FD)库
--------

SWI-Prolog的clp(fd)库是由马库斯·特里斯卡为完成他的博士论文而编写的。clp(fd)代表__有限域上的约束逻辑程序设计__。

clp(fd)是SWI-Prolog中可用的几种约束求解器之一。其他的有：clp(b)，clp(qr)。clp(b)处理布尔值。clp(qr)处理有理数和实数。约束处理规则是一个用于创建你自己的约束系统的工具（结合其他东西）。

启用clp(fd)库很容易： 

----------------------------
:- use_module(library(clpfd)).
----------------------------

这将建立一个编译时的钩子，可以优化一些clp(fd)约束，并加载运行时库。

变量
--

在计算机科学中，我们可以不那么严格地使用__变量__这个术语。

替代变量
~~~~

在命令式语言中，比如Java，变量是可变的。
它们在不同时候有不同的值。

在C语言中，像变量x：

---------------------
int x;

... 这里怎么样了？...

x = 5;
---------------------

总是有一个值。在我们将5赋值给该变量之前，它的值会是任何碰巧储存在其内存位置的值（这对所有安全程序员来说都是一个快乐的源泉）。

逻辑变量
~~~~

在逻辑式语言中，变量是不同的。它们更像高中代数中的变量或__未知数__。 

在Prolog中，变量可以是绑定或非绑定的。非绑定变量可以匹配任何值。一个绑定变量仅与一个模板一致。

实际上，我们要么知道，要么不知道这种变量的值。

当我们试图给变量匹配值时，我们实际上是在问：“我们把答案代入左边和右边的式子，它们能否配平？”鲍勃声称自己是主城市长的好友。如果鲍勃是《主城日报》的编辑，这很可能是可信的。但如果鲍勃说他从没来过主城，这就有些矛盾了。

在Prolog中，一个原子的结果只有两种可能。完全不知道，或完全知道。显然，在列表或项中可能有非绑定变量，但对于每个变量，只有这两种状态。

约束变量
~~~~

但在现实世界，我们可以讲出更多关于变量的内容。 

有时我们可能不知道确切的值是多少，但我们知道它的值会是一组可能值的其中之一。我们把这组值称为这个变量的__域__。

有时我们可能不知道它的值是多少，但可以说出它比其他一些我们同样不知道值的变量要大。我们说这个变量是**被约束**的。

随着我们开始积累约束条件，我们就能围绕约束条件进行推理。
假设我们有两个整数变量，X和Y。

现在我告诉你，X在0到10之间。

接着，Y在4到8之间。

最后，X大于Y。 

你可以推断出，X在5到10这个更窄的范围内，因为Y的最小值是4，并且X必须比Y至少大1。

这便是用clp(fd)表述出来的的样子。如果你不能完全理解这些，也不要担心。

-------------------------------------------
:- use_module(library(clpfd)).         <1>

test(X, Y) :-
    X in 0..10,         <2>
	Y in 4..8,      <3>
	X #> Y.         <4>
	 

14 ?- test(X, Y).
X in 5..10,             <5>
Y#=<X,                  <6>
Y in 4..8.
-------------------------------------------

<1> 导入clp(fd)库
<2> 使用__in__运算符，约束X在0到10之间
<3> 使用__in__运算符，约束Y在4到8之间
<4> 使用__#>__运算符，约束X比Y大
<5> 现在X被约束到5到10之间
<6> 现在Y被约束为=< X - 1（同样是X>Y），且范围为4到8。

当我们把一个变量约束为一个值时，会发生一些神奇的事——我们现在已经得出此变量的值，因此可以绑定此变量。在clp(fd)中，确实发生了这种情况！假设我将X约束在0到5之间，将Y约束在4到8之间，并且X> Y，那么现在X突然绑定为5了。ground(X)成功了，并且X是一个非常普通的绑定变量。

-------------------------------
:- use_module(library(clpfd)).

test2(X, Y) :-
     X in 0..5,
	 Y in 4..8,
	 X #> Y.
	 
16 ?- test2(X,Y).
X = 5,     <1>
Y = 4.     <2>

-------------------------------

<1> X被绑定，就像在正常的Prolog中那样
<2> 注意，Y也被绑定了。此外，它移除了原先与约束相关的信息

.运行练习
***********************

输入并尝试以上两个例子。使用图形调试器进入它们，以查看列出的约束。

*********************** 

.回溯练习
**********************

------------------------------
:- use_module(library(clpfd)).

foo(X) :- X in 1..3 .
foo(X) :- X in 5..7 .
foo(X) :- X in 8..12 .
------------------------------

如果查询foo(X)，并通过回溯得出所有的解，将会发生什么？
预测会发生什么，并尝试它。你的预测正确吗？

********************** 

实现
~~

SWI-Prolog具有给变量添加**属性**的能力。这个是给变量附加附加元数据。如果你有兴趣，可以阅读更多有关属性变量的内容： http://swi-prolog.org/pldoc/man?section=attvar[SWI-Prolog网站]。

clp(fd)使用这种属性数据修饰约束变量。然后clp(fd)实现了约束编程，并成为了各种常见Prolog一致采用的扩展。 

本教程结尾将对此作更多介绍。

.属性练习
*********************

额外加分 -

考虑除了用于约束，变量属性的另一种用法。

********************* 

域
~

clp(fd)中的(fd)表示__有限域__。该域可以具有数百万个值，但它必须是一个有限列表。

我们只关心有着有限域的变量，也就是名称中所强调的**有限域**那样。就我们的目的而言，这意味我们要对整数集的域进行推理。 

`clp(fd)` 可以用于 `[天空, 陆地, 海洋]` 这样的域，但优化效果不佳。映射“天空=0, 陆地=1, 海洋=2”，然后就可以说它的域是 `0..2` 了，这样会更好。
任何可能的有限列表都可以映射为整数有限子集。

乍一看，这么做可能显得有些笨拙，但实际上跟使用数组索引没什么不同。然而，更大的问题可能是调试——由整数组成的列表可能让人不知所云。编写一些调试代码提取并输出数据，可能会有帮助。

一个示例
----

我对那些喋喋不休、毫无根据的讨论总是感到恼火。那么在这里展示一个典型的约束程序，并给一些部分附注简要说明。你可能还不了解这些部分。

“SEND + MORE = MONEY”密码算术问题是约束编程中的经典“hello world”。这个问题要求将0到9数字分配给各种字母，使它们拼出SEND MORE MONEY，当按照十进制读取数字时，会形成真正的算式。数字不允许有前导0。

------------------------
:- use_module(library(clpfd)).         <1>

puzzle([S,E,N,D] + [M,O,R,E] = [M,O,N,E,Y]) :-   <2>
        Vars = [S,E,N,D,M,O,R,Y],     <3>
        Vars ins 0..9,      <4>
        all_different(Vars),        <5>
                  S*1000 + E*100 + N*10 + D +     <6>
                  M*1000 + O*100 + R*10 + E #=
        M*10000 + O*1000 + N*100 + E*10 + Y,
        M #\= 0, S #\= 0,    <7>
		label(Vars).  <8>
		
9 ?- puzzle(X).
X = ([9, 5, 6, 7]+[1, 0, 8, 5]=[1, 0, 6, 5, 2]) ;  <9>
false.
------------------------

<1> 导入clp(fd)库
<2> 注意，clp(fd)不是pce或准引用那样的嵌入式领域特定语言。clp(fd)随Prolog一同使用，增多了语义。
<3> 为方便起见，列出了我们要约束的所有变量
<4> 把Vars中的每个变量的值限制在0..9之间（含）
<5> 添加约束条件，它们的值必须是不同的
<6> 添加定义问题的算术约束条件
<7> 单词以M和S打头，因此这两个字母不能为0
<8> 尝试尽可能确定变量的数值
<9> 注意，从这里开始再没有有趣的归因，这个只是用来返回解

.FortyTenTen练习
**********************

1)通过修改程序来解决密码算术FORTY + TEN + TEN = SIXTY

2) 如果允许前导0，SEND+MORE=MONEY是否还有其他的解？修改程序，找出答案。

********************** 

 标注
--

添加约束条件是好的，但除非我们能和往常一样简单地确定变量，否则它的用处不大。确定了所有变量的解称为'确定解'。

有一个较细微的机制可以做到这一点。 

如果把域缩减至单个值，就能确定变量。

通常你能轻易限定变量。一般用++X = 3++这样的语句把变量确定为单个值。 

谓词++indomain/1++在回溯时，会不断给变量绑定其可能值。

通常，我们调用++label/1++或++labeling/2++来找出单个的确定解。++label/1++和++labeling/2++是非确定性的，在每次回溯时，都会绑定一组不同的值。

当然，我们的约束系统可能不够强大，不足以表述各种约束条件。既然这样，我们就必须依靠Prolog程序员所熟悉的生成和测试搜索策略。有了约束系统，生成和测试会成为 

. 约束
. 生成（通过标注）
. 测试

实际上，大多数clp(fd)程序遵循先约束后标注这种通用模式。

[TIP]
建立模型并对各个谓词进行标注和剩余搜索是良好的做法。这使得在标注之前更容易检查这个模型。

++labeling/2++有大量能够影响变量选取策略的选项。由于clp(fd)程序花费的大部分时间通常是用于标注，因此我们会在后面详细介绍这些内容。而现在我们使用++label/1++，它的默认参数比较合理。

++labeling/2++中的选项也能用来处理__最大收益__的优化问题。

简单约束
----

clp(fd)提供了一组基本、简单的约束语句。

请记住，clp(fd)与整数一起使用。

.简单的运算符
-------------------
X #>= Y
X #=< Y
X #= Y
X #\= Y
X #> Y
X #< Y
-------------------

[TIP]
你可以把++#=++当作++is++的一种声明式版本来使用，不然就不像是在编写clp(fd)程序。++X is 3+Y++需要Y是确定的；而++X #= 3+Y++，在X确定、Y没确定的情况下也是有效的。

[TIP]
++X #< Y++可以省去不必要的对调。例如，如果在锦标赛中玩家1和3已配对，再考虑3和1的配对是没有意义的。思考下面取自SWI-Prolog文档的示例，它找出了能让4个人配对的所有形式：

.消除对调
====================

-------------------------------
?- Vs = [A,B,C,D], Vs ins 1..4,
        all_different(Vs),
        A #< B, C #< D, A #< C,
   findall(pair(A,B)-pair(C,D), label(Vs), Ms).
Ms = [ pair(1, 2)-pair(3, 4),
       pair(1, 3)-pair(2, 4),
       pair(1, 4)-pair(2, 3)].
-------------------------------
	   
====================


.严格递增练习
*****************************

编写一个谓词++increase/1++ ，它接收一个列表，然后约束其严格递增。

首先记录你预计每个查询的结果。然后测试你的谓词的行为是否符合你的预期。

------------------------

?- increase([1, X, 3]).

?- increase([1, X, 4]).

?- increase([1,X, Y, 4]).

?- increase([1,2]).

?- increase([1,X]).

------------------------


*****************************


约束为一个域
------

Clp(fd)围绕着变量的域。 

变量的__域__是它可以取的一组值。

在clp(fd)中，每个变量必须被限制到“有限域”，以进行推理。
在尝试标注所给的变量之前，你__需要__把域赋给它们。如果不是，你将得到令人困惑的异常，__错误：参数未被充分实例化__。

-----------------
X in 5..10,   <1>
Y in 1..10,   <2>
Y #> X        <3>
-----------------

<1> X的域设定为5到10
<2> Y的域设定为-1到10
<3> 约束Y大于X，这样就能推断出Y的域。Y必须为6、7、8、9、10其中之一。


奇怪的是，对于所有有关__有限__域的讨论，都允许像 `4..sup` 那样，把变量约束到4至无穷大的域。`inf` 则表示负无穷大。

In和Ins
~~~~~~

你可以使用++in++和++ins++运算符来限制变量的域。

++in++和++ins++都是针对右边的域。
一个域是一个简单范围或用\/运算符把几个简单范围组合成的一个并集。

一个简单域可以是单个数字或由双点相连的一组边界。边界可以是数字，或表示最小数的++inf++，或表示最大数的++sup++。其中任何一个都可以是确定变量，比如++N=3, X in 1..N++。

++\/++运算符 
~~~~~~~~~

++\/++运算符可以把几个域并在一起。

.并集
--------------------
1..3 \/ 5..7
--------------------

下面是一个更复杂的域的示例。

.复杂域
=====================

---------------------
V in inf.. -2 \/ 0 \/ 2..16 \/ 18..sup
---------------------

=====================

++in++用于约束单个变量。

++ins++把一个变量列表中的变量都约束为同样范围的值，相当于是具有in性质的映射列表。

.重叠域练习
********************************************************

尝试上面的__复杂域__示例，然后将最后一个范围改为 '16 .. sup` 。

注意，它简化了这个域。

********************************************************


来自数据的域
~~~~~~

如果你的域需要从输入数据中获取呢？假设我们从某处得到一个数据结构，需要以某种方式对其约束。

将你的域组合为一个项 `MyDomain` ，并使用 'X in MyDomain' 。下面是一个示例

.来自数据的域
===================

--------------------------------------------------------------------
% Bases是一个整数列表。用B表示Bases的一个成员，约束Var为B..B+2

two_domains(Bases, Var) :-
	make_two_domains(Bases, Term),
	Var in Term.

make_two_domains([H], H..HT) :-
	HT is H + 2.
make_two_domains([H | T], '\\/'(H .. HT, TDomain)) :-
	HT is H + 2,
	make_two_domains(T, TDomain).
	
25 ?- two_domains([1, 8, 16], V).
 V in 1..3\/8..10\/16..18 ;
--------------------------------------------------------------------

===================

算术运算符
-----

你可以用算术约束来进行很多约束工作。

可以采用中缀算术表达式来进行约束。 

---------------
X + 2 #= Y * 3
---------------

可用的运算符有 

- 一元运算符-，
- +，
- -，
- *，
- / （截断整除）， 
- ^ （ 幂），
- min， 
- max，
- mod，
- rem，
- abs

逻辑运算符
-----

++`#\`++否定
~~~~~~~~~~

一元运算符。反转所包含的约束。

++`#/\`++和
~~~~~~~~~~

同时约束两边。

++`#\/`++或
~~~~~~~~~~

至少约束一边。

具体化
---

具体化是通过约束来控制其他约束的过程。clp(fd)包含两个用于具体化的操作符。

++`#<==>`++等价
~~~~~~~~~~~~~

每边是个布尔型变量（一个0或1）或是个约束。调节约束，使它们都成立或都不成立。

++`#==>`++蕴含
~~~~~~~~~~~~

如果左边成立，则右边必须成立。
如果左边不成立，则右边被忽略。


.一些具体化的约束
=============================

在化工厂里有一个反应容器。这个容器中的温度被限定为必须低于某个特定数值，并在不是__启动__模式的情况下，还要高于另一个值。

-----------------------------

chem_tank(Temp, Startup) :-
	Temp #< 800,
	#\ Startup #==> Temp #> 300.

-----------------------------

我们可以将启动模式定义为起始后的10分钟以内。

-----------------------------

chem_demo(Temp, TimeNow, StartTime) :-
	chem_tank(Temp, TimeNow - StartTime #< 10).

-----------------------------

注意，++StartTime++是**作为一个约束**传入的，并且使用了逻辑运算符。

这意味着你可以构建、传递约束，并在随后应用它们，或者使用它们构建更复杂的约束。

=============================

.工作练习
************
编写一个匹配人和工作的小系统。这些工作对教育水平、能举起的重量、年龄、离家距离都有要求。要能够记录在个人履历中特殊约束条件——比如，鲍勃在假释期间，离家不得超过20英里；莎莉需要一个帮手，但她不喜欢那些不工作时到处闲逛的工人，她还想要那个帮手住在10英里以外。

人们都有些有趣的状况，所以试着将其概括出来。 

对于这个练习，你可以（不现实地）假设用户了解Prolog。
************


常用约束
----

现在我们来看clp(fd)库中提供的一些更__方便__的谓词。大多数这些谓词同时设定了大量的简单约束条件。

除了引入了方便的谓词外，这也是使用约束开发工具的好办法。

下面是一些在大多数约束情境下比较有用的约束。

length(List, Length)
~~~~~~~~~~~~~~~~~~~~

这个当然是过去那个好用的长度谓词。在length(-, +)模式下生成非绑定变量列表很有效。 

[TIP]
在call + 1的情况下通过++length_(Length, List) :- length(List, Length).++列出非绑定变量列表有时很方便。
像++length(List, 9), maplist(length_(9), List)++就可以给出非绑定变量的二维数组。

.length练习
****************

------------
?- length(X, 5).
------------

现在尝试 

------------
?- length(X, Y).
------------

****************

all_different(List)
~~~~~~~~~~~~~~~~~~~

经常会用到这个谓词。它能将列表的成员约束为不同的值。

.all_different示例
----------------------
 ?- length(List, 4),List ins 1..4, all_different(List), List = [1,_,3,4].
List = [1, 2, 3, 4].
----------------------

++all_different/1++与__鸽巢原理__结合起来会很有用，该原理指，如果你有N个变量，每个元素在1..M的范围内，且N>M，那么一定有两个变量具有相同的值。出于这个原因，在上面的例子中，List肯定始终是[1,2,3,4]的排列。

all_distinct的工作方式类似于all_different，但是它会__尽力__检测何时所有内容都不相同。

例如，我们尝试将3个变量约束在1..2范围中，且值不同——这是不可能的。

------------------------
24 ?- X in 1..2, Y in 1..2, Z in 1..2, all_different([X,Y,Z]).
X in 1..2,
all_different([X, Y, Z]),
Y in 1..2,
Z in 1..2.

25 ?- X in 1..2, Y in 1..2, Z in 1..2, all_distinct([X,Y,Z]).
false.

26 ?-
------------------------

在上述内容中，**all_different**没能检测到X、Y和Z只有两个可能值，因此其中两个变量必定相同。

**all_distinct**会做更多工作来分析其变量的域，并会检测到这种情况。但是，使用__all_distinct__时cpu占用较高——因此，这需要提前修剪搜索树以提升性能。

如果你遇到性能问题，那么使用其中一种方法进行审查可能是值得的。

tuples_in(+ListOfVariableTuples, +ListOfAcceptedTuples)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

列出一些变量的可选组合列表是很常见的。一种常见的情况是点美式餐，如果你点一份套餐，套餐的价格包含一份主菜和两个配菜；但如果你点的是馅饼，就只有一个配菜，等等。你需要列出所有不同的组合。

SWI-Prolog文档有一个很酷的为一个行程选择火车班次的演示。

.火车行程
==============================

------------------------------
:- use_module(library(clpfd)).

trains([[1,2,0,1], % 出发站，到达站，离开时间，到达时间
        [2,3,4,5],
        [2,3,0,1],
        [3,4,5,6],
        [3,4,2,3],
        [3,4,8,9]]).

threepath(A, D, Ps) :-
        Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],
        T2 #> T1,
        T4 #> T3,
        trains(Ts),
        tuples_in(Ps, Ts).
		
?- threepath(1, 4, Ps).
Ps = [[1, 2, 0, 1], [2, 3, 4, 5], [3, 4, 8, 9]].
------------------------------

==============================

除了把它作为一种很酷的寻路方法之外，还请注意，我们无需进行任何标注。这里只有一个解。

如果发现元组看起来像++[[1,2], [2,7], [3,8]…]++，请考虑使用++element/3++进行代替。

.tuples_in练习
*******************

no 1. 修改火车行程程序，使其能查找任意数量火车的路线，而不只是3趟。

no 2. 你需要给出一张有资格晋升的员工列表。
你有这张包含列表的列表。每个内部列表是一个员工的履历。其中的字段表示员工编号、最后考核成绩、违反安全规定次数、任职时间、晋升所需时间

---------
employees([
   [1, 75, 0, 30, 25],
   [2, 83, 0, 45, 25],
   [3, 90, 1, 45, 50],
   [4, 45, 3, 75, 25],
   [5, 89, 0, 52, 50]
   ]).
---------

最后考核成绩高于80分、违反安全规定次数不超过1次、任职时间超过晋升所需时间的员工方有资格晋升。

no 3. 最后一列，晋升所需时间，还没有标准化。一个员工要么是团队成员，要么是团队领导。团队成员需要25周的任职时间，团队领导需要50周的任职时间才能晋升。首席架构师决定把这些数据抽取到第二张表中，这样就能轻松更改这些数字。

------------
employees([
   [1, 75, 0, 30, 1],
   [2, 83, 0, 45, 1],
   [3, 90, 1, 45, 2],
   [4, 45, 3, 75, 1],
   [5, 89, 0, 52, 2]
   ]).

time_in_grade([[1,25], [2,50]]).

------------

更新练习2，使用新的数据格式。

*******************

数独
~~

好吧，这个并不是真正的数独谓词，但当变量被自然地表示为一个二维网格时，用++transpose(+Matrix, ?Transpose)++谓词来处理它会很有效。

将这个网格表示为一个包含列表的列表。每个列表就是一行。

许多约束谓词可以处理列表中元素的相邻关系。
如果你需要对行进行操作，则可以使用maplist。
要对列进行操作，可以转置矩阵，它们就变成成行了。

[TIP]
不，你不需要将其转置回来。新的转置矩阵与原先的列表共用数据。对它做出任何约束就能对原先的列表进行约束。

例如，下面是一个解决“吵架的孩子”问题的程序。
通过只处理行，它就被大大简化了。

. 吵架的孩子
---------------------

/*
	 孩子吵架概述

	 16个孩子要坐在4 x 4的椅子上。

         其中有8个女孩（编号1..8）和8个男孩（编号9..16）。

     1、3、5、8号认为男孩很烂，9、10、11、14号认为女孩很恶劣

	 这几对是冤家：

	 [[1,2], [4,6], [4,7], [4, 9],[9,11], [12, 14], [14,16]]

 */

length_(Length, List) :- length(List, Length).

child_row(X) :- X ins 1..16 .

ww(X) :-
	write(X),
	write('/').

print_row(Row) :-
	maplist(ww, Row),
	nl.

children(Class) :-
	length(Class, 4),
	maplist(length_(4), Class),
	maplist(child_row , Class),
	maplist(row_compatible, Class),
	transpose(Class, TransClass),
	maplist(row_compatible, TransClass),
	flatten(Class, FlatClass),
	all_different(FlatClass),
	maplist(label, Class),
	maplist(print_row, Class).

row_compatible([A,B,C,D]) :-
	compatible(A, B),
	compatible(B, C),
	compatible(C, D).

compatible(A, B) :-
	not_enemy(A, B),
	not_enemy(B, A),
	sex_compatible(A, B),
	sex_compatible(B, A).

not_enemy(A, B) :-
	NotA #\= A #\/ NotB #\= B,
	tuples_in([[NotA, NotB]],
		    [[1,2], [4,6], [4,7], [4, 9],[9,11], [12, 14], [14,16]]).

sex_compatible(A, B) :-
	A in 1\/3\/5\/8 #==> B #=< 8,
	A in  9..11\/14 #==> B #> 8.

---------------------

.transpose练习
************

编写一个用于roguelike游戏的谓词。

你的游戏板是一个二维数组（包含列表的列表）。每一格包含下列元素之一 

* 0 - 地面
* 1 - 墙
* 2 - 怪物
* 3 - 玩家

编写一个谓词，can_move(+Board, -Moves)。Board是上面定义的游戏板。SafeMoves是一个包含列表的列表，其中玩家可以移动的地方为1，不能移动的地方为0。必须遵守以下规则：

*  玩家可以沿着水平、垂直但不能是对角线方向移动0、1、2或3个空格。
*  玩家不能穿过或到达墙上
*  玩家在行动时不能穿过或与怪物相邻
*  玩家不能离开游戏板

示例运行（出于可读性采取了一些措施）：

.游戏板示例
-----------------
board([
[1,1,1,1,1,1,1,1],
[1,0,2,0,0,0,0,0],
[0,1,0,0,0,2,0,0],
[0,0,1,0,0,0,0,3],
[0,0,0,1,0,0,2,0],
[0,0,0,0,1,0,0,0],
[0,0,0,0,0,1,0,0],
[0,0,0,0,0,0,1,0],
[0,0,0,0,0,0,0,1]
]).

?- board(B), can_move(B, M), writeq(M).
M = [
[0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,1,1],
[0,0,0,0,0,0,0,1],
[0,0,0,0,0,0,0,1],
[0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0]
]
-----------------

提示：编写一个谓词，以一种更可读的格式输出M。额外加分：可以使用终端着色库实现这一点

************

zcompare(?Order, ?A, ?B)
~~~~~~~~~~~~~~~~~~~~~~~~

当你需要了解两个未标注变量的域之间的关系时，zcompare很有用。

--------
10 ?- X in 0..10, Y in 11..20,zcompare(C, X, Y).
C = (<),
X in 0..10,
Y in 11..20.

11 ?- X in 0..11, Y in 11..20,zcompare(C, X, Y).
X in 0..11,
zcompare(C, X, Y),
freeze(C, clpfd:zcompare_(C, X, Y)),
Y in 11..20.

--------

我承认，第二个让我有些困惑。结果表明，C仍然不受约束，因为当X和Y的域重叠时，我们无法真正分辨X和Y之间的关系。但是，如果稍后绑定C，它将返回并约束X和Y！

--------
15 ?- X in 0..11, Y in 11..20,zcompare(C, X, Y),C = <, writeln(C).
<
C = (<),
X in 0..11,
X#=<Y+ -1,
zcompare(<, X, Y),
Y in 11..20.
--------

[TIP]
安妮在这里表示，看起来像这样=8cO，试着想象使用了大量zcompare的调试代码

.zcompare练习
******************

创建一个约束谓词++same_side_of_line/4++，其参数是词典形式

------------
point{x:12.34, y:56.78}
------------

前两个参数是直线上的点，后两个参数是两个测试点。 如果两个测试点都在直线的同侧，或两个都在直线上，则谓词成功，约束成立。

******************

资源
--

clp(fd)非常适合解决资源受限的问题。

调度问题通常是一系列资源约束问题的组合。 

大多此类问题能用基本的约束谓词解决，但内置在clp(fd)中的几个约束谓词也很好用。
++sum/3+和+scalar_product/4++非常简单实用。 

++scalar_product/4++的作用可能不是很明显。它在定义不同事物具有不同__成本__（时间、金钱或其他）的关系时很有用。

.便士糖
------------------------

%
%  便士糖示例
%  蒂米有25分
%  口香糖球1分
%  士力架10分
%  太妃糖2分
%  甘草糖5分
%
%  蒂米有哪些可选方案？
%  假设蒂米花了整整25分
scalar_test(Candy) :-
	Candy = [_Gumball, _Snickers, _Toffee, _Licorice],
	Candy ins 0..sup,
	scalar_product([1, 10, 2, 5], Candy, #=, 25),
	label(Candy).

6 ?- scalar_test([Gumball, Snickers, Toffee, Licorice]).
Gumball = Snickers, Snickers = Toffee, Toffee = 0,
Licorice = 5 ;
Gumball = Snickers, Snickers = 0,
Toffee = 5,
Licorice = 3 ;
Gumball = Snickers, Snickers = 0,
Toffee = 10,
Licorice = 1 ;
Gumball = Toffee, Toffee = 0,
Snickers = 1,
Licorice = 3 ;
Gumball = 0,
Snickers = Licorice, Licorice = 1,
Toffee = 5 ;
...

------------------------


[TIP]
尝试在便士糖示例中删去++Candy ins 0..sup++这一行。
会发生什么？

排序
--

我们经常需要让事物按特定的顺序进行排列。 

这些约束谓词有助于进行排序。

chain(+List, +Relation)
~~~~~~~~~~~~~~~~~~~~~~~

Chain谓词会对列表中每对相邻元素间建立关系约束。

.Chain示例
--------------

chain_example([A,B,C,D]) :-
	chain([A,B,C,D], #>=).
	
?- chain_example(X).
X = [_G4676, _G4679, _G4682, _G4685],
_G4676#>=_G4679,
_G4679#>=_G4682,
_G4682#>=_G4685.

--------------


lex_chain(+Lists)
~~~~~~~~~~~~~~~~~

++lex_chain/1++更有趣。它接受一个包含列表的列表。

它将内部列表约束为__词典非递减__顺序。
这意味着应该从左边开始根据纵行的词典顺序排序它们。这是我们通常对文本进行排序的方式

-------------
andy   
babble <-- 在andy后面，因为a在b前面
beef   <-- 在babble后面，因为a在e后面
been   <-- 在beef后面，因为f在n前面
-------------

除了排序文本这种显而易见的用途外，++lex_chain++还能用来排序其他东西。

.医院的病人
******************

医院里的病人的一组编码信息构成了一个项。

------------
patient(ID, Name, YearAdmitted, MonthAdmitted, DayAdmitted, HourAdmitted, MinuteAdmitted, Status, Payment)
------------

状态为0（正常）或1（紧急）。

付款方式为0（个人）、1（保险）或2（医疗补助）。

下面是一些病人信息

------------
patient(1, 'Bob Jones', 2014, 10, 1, 4, 55, 0, 2).
patient(2, 'Sally Smith', 2014, 9, 29, 5, 15, 1, 0).
patient(3, 'Ted Overton', 2014, 9, 30, 14, 15, 0, 0).
patient(4, 'Arnold Abouja', 2014, 10, 1, 5, 0, 0, 0).
patient(5, 'Seth Humbolt', 2014, 10, 1, 5, 10, 0, 0).
------------

根据以下规则限定病人：

1. 先看紧急的病例，再看正常的病例。

2. 对于处于相同状态（紧急/正常）的病人，按其到达顺序接诊，除非 

3. 如果是个人或是使用保险付费的病人在使用医疗补助的病人到达后的一小时内到达，先接诊前者。

提示：使用lex_chain

******************

element(?Index, +List, ?Element)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Element是++nth1/3++的等价约束谓词。

它根据元素在列表中的位置来约束元素。元素必须是列表中第Index个成员，从1开始计数。

.苏西调情示例
===========================================

---------------------------
%
% 苏西想和纳森调情
% 但当她的老男友约翰在身边时就不会
%
% 苏西、纳森和约翰都必须参加课程1..6
%
% 苏西如何安排日程以便能至少在3个课程上调情？

flirt_constraint(Suzy, Nathan, John, FlirtPeriods) :-
	length(Suzy, 6),
	length(Nathan, 6),
	length(John, 6),
	Suzy ins 1..6,
	Nathan ins 1..6,
	John ins 1..6,
	all_different(Suzy),
	all_different(Nathan),
	all_different(John),
	FlirtPeriods = [A,B,C],
	FlirtPeriods ins 1..6,
	A #< B,    % 删除不需要的对调
	B #< C,
	flirty_period(A, Suzy, Nathan, John),
	flirty_period(B, Suzy, Nathan, John),
	flirty_period(C, Suzy, Nathan, John),
	label(Suzy),
	label(FlirtPeriods).

flirty_period(Period, Suzy, Nathan, John) :-
	Class in 1..6,
	DiffClass #\= Class,
	element(Period, Suzy, Class),
	element(Period, Nathan, Class),
	element(Period, John, DiffClass).
---------------------------

===========================================

元素谓词的一个非常重要的用途是帮助约束不同的事实。 

例如，假设我们要按照名字的字母顺序给一群人进行编号。现在我们要使其中一对成为浪漫的伴侣。作为异性恋和重视年龄代沟的人，我们要限制他们是异性并且年龄差在10年以内。

这个示例还显示了从索引号得出我们最终想要的——名字。出于教学之便，这个示例违反了有限域上的约束逻辑程序设计的范式——在一个谓词中设定模型，用另一个谓词标注。

.浪漫的伴侣
==============================

------------------------------
:- use_module(library(clpfd)).

names([amy,bill,charley,deanna,eric,frieda,george,harley]).
% 女人是1，男人是0
genders([1,0,0,1,0,1,0,0]).
ages([22,19,73,65,40,38,25,27]).

% 映射共用的姓名列表
romance(A, B) :-
    names(Names),
    length(Names, NameLength),
    AIndex in 1..NameLength,
    BIndex in 1..NameLength,
    genders(G),
    element(AIndex, G, AG),
    element(BIndex, G, BG),
    AG #\= BG,
    ages(Ages),
    element(AIndex, Ages, AAge),
    element(BIndex, Ages, BAge),
    AAge #< BAge #==> AAge + 10 #>= BAge,
    AAge #>= BAge #==> BAge + 10 #>= AAge,
    AIndex #< BIndex, % 消除不想要的对调和自反关系
    label([AIndex, BIndex]),
    nth1(AIndex, Names, A),
    nth1(BIndex, Names, B).

	
7 ?- romance(A,B).
A = amy,
B = bill ;
A = amy,
B = george ;
A = amy,
B = harley ;
A = charley,
B = deanna ;
A = eric,
B = frieda ;
false.
	
------------------------------

==============================

circuit(+List)
~~~~~~~~~~~~~~

关于这方面的文档，所带来的困惑要多于启发。

++circuit/1++读取变量列表并将其约束为一个__回路__，在第1个数字之后每个数字的关系为Vn+1 = Vn mod L + 1。其中Vn是元素，Vn+1是下一个元素，L是列表长度。

因此，这个就是__时钟算术__。

.circuit示例
-----------------
?- length(Vs, _), circuit(Vs), label(Vs).
Vs = [] ;
Vs = [1] ;
Vs = [2, 1] ;
Vs = [2, 3, 1] ;
Vs = [3, 1, 2] ;
Vs = [2, 3, 4, 1] .
-----------------

自动机
~~~

自动机在排序领域举足轻重。

自动机出自__自动机理论__，即抽象机器的研究。++automaton/3++将其第一个参数约束为可以被有限接受器识别的语言元素。++automaton/8++会将其第一个参数约束为下推接受器可以识别的语言元素。

会做些什么？（数学家们避开眼睛，我将快速、不严格地解释一下有限自动机）。

有限自动机有点像跳房子游戏。你有一组（有限的）__状态__及其之间有方向弧线。每个弧线都与一个输入关联。下面是一个典型的自动机。

image::images/automatona.png[一个典型的自动机]

从绿色状态开始。读取序列中的第一个元素，如果那里有一个用它标注的弧线，跳转到那个状态。如果没有，则你的序列不在这个语言之中。如果存在，请在新状态下重复——读取下一个元素，然后尝试沿弧线执行。如果你处于蓝色状态，那么到此为止，你所读取的内容就是该语言的一部分。

我们的语言接受一个或多个0，接着是一个1，然后是一个2。

绿色状态称为源状态，蓝色状态为宿状态。一个状态可以同时是源状态和宿状态。

下面是如何在SWI-Prolog中编写它：

.单源自动机
===========================

-------------------------

single_source_automaton(Vs) :-
	automaton(Vs, [source(a), sink(d)],
		  [arc(a,0,b),
		   arc(b,0,b),
		   arc(b,1,c),
		   arc(c,2,d)
		   ]).

demo_single_source(Vs) :-
	length(Vs, 4),
	single_source_automaton(Vs),
	label(Vs).

-------------------------

===========================

下面是第一个自动机的变体，它与第一个自动机相仿，但却使所有数字加了10，因此它会接受10、10、10、10、11、12这样的序列。

image::images/automaton.png[变体，接受原先各个数字加10形成的序列]

.多源自动机
==========================

----------------------

multi_source_automaton(Vs) :-
	automaton(Vs, [source(a),source(e), sink(d), sink(h)],
		  [arc(a,0,b),
		   arc(b,0,b),
		   arc(b,1,c),
		   arc(c,2,d),
		   arc(e,10,f),
		   arc(f,10,f),
		   arc(f,11,g),
		   arc(g,12,h)]).

demo_len(Vs) :-
	length(Vs, 4),
	multi_source_automaton(Vs),
	label(Vs).

----------------------

==========================

automaton/3示例——某些员工晚上不工作，其他一些周末不工作，我们使用自动机将其编码，读取轮班人员的列表。
也许员工示例够多了——那换成有效消息如何？

Automaton/8——暂停，直到我理解为止

计数器示例——对员工示例示例进行拓展，获得员工的最大和最小班次数。


调度
--

日程安排是我们每天都要做的事情。比如鲍勃只能在2点到3点见面；你要连续几个小时不受打扰地考虑数据库；妈妈要过来吃午饭。这也可能是一个重要的的经济约束情况——工厂可以在3月到7月生产拖拉机部件，但得为圣诞节转而生产豆豆娃。

序列化
~~~

序列化表示不能在两个地方出现同样的约束。它需要两个长度相同的列表，第一个是开始时间列表，第二个是持续时间列表。需要限制它们开始和持续时间所定义的区间不重叠。注意，它不必按顺序排列——即，serialized([4,0,2], [1,1,1])也是可行的。

.日程安排
=====================

----------------------
:- use_module(library(pairs)).

my_schedule_today(Starts, Durations) :-
  % 无序的今日待办事项清单
  % 这些都是24小时制的小时，在实际问题中，我们可能会用到分钟
    Starts = [PrepForSmith, MeetWithSmith, _WriteDBInstaller, Lunch, _CallAlice, _ReadDocs],
  % 事项所需的时间
    Durations = [2, 1, 2, 1, 1, 1],
  % 使它们都在上午9点到下午5点的范围内
    Starts ins 9..17,
  % 并确保午餐时间在中午或下午1点
    Lunch in 12 \/ 13,
  % 与史密斯的会面时间定于下午1点
    MeetWithSmith #= 13,
  % 会面前的准备工作
	PrepForSmith #< MeetWithSmith,
  % 进行序列化
    serialized(Starts, Durations).

demo_my_schedule(Starts, Durations) :-
	my_schedule_today(Starts, Durations),
	append(Starts, Durations, Vars),
	label(Vars),
	pairs_keys_values(NameDurs ,
       [会面前的准备工作, 与史密斯会面, 编写数据库安装程序, 午餐, 给爱丽丝打电话, 阅读Flubbercalc文档], Durations),
	pairs_keys_values(Pairs, Starts, NameDurs),
	keysort(Pairs, Sorted),
	pairs_keys_values(Sorted, SortStarts, SortNameDurs),
	print_sched(SortStarts, SortNameDurs).

print_sched([], _).
print_sched([Start | ST], [Name-Duration | T]) :-
	format('~w：~w  （~w小时）~n', [Start, Name, Duration]),
	print_sched(ST, T).

8 ?- demo_my_schedule(Starts, Durations).
9：会面前的准备工作  （2小时）
11：给爱丽丝打电话  （1小时）
12：午餐  （1小时）
13：与史密斯会面  （1小时）
14：编写数据库安装程序  （2小时）
16：阅读Flubbercalc文档  （1小时）
Starts = [9, 13, 14, 12, 11, 16],
Durations = [2, 1, 2, 1, 1, 1] ;
9：会面前的准备工作  （2小时）
11：给爱丽丝打电话  （1小时）
12：午餐  （1小时）
13：与史密斯会面  （1小时）
14：编写数据库安装程序  （2小时）
17：阅读Flubbercalc文档  （1小时）
Starts = [9, 13, 14, 12, 11, 17],
Durations = [2, 1, 2, 1, 1, 1] 

----------------------

=====================

global_cardinality/3
~~~~~~~~~~~~~~~~~~~~

++global_cardinality/3++计算每个值在第一个参数中出现次数。

下面是一个示例。假设我们有一个24/7便利店轮班的员工名单。

----------------------------------------------------
shifts([1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,5,6,4,5,3]).
----------------------------------------------------

我们想知道每个员工轮班了多少次。

----------------------------------------------------
shifts([1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,5,6,4,5,3]).

count_shifts(Counts) :-
     shifts(Shifts),
     bagof(X, between(1,6,X), Keys),
     length(Values, 6),
     pairs_keys_values(Counts, Keys, Values),
     global_cardinality(Shifts, Counts, []).
----------------------------------------------------

记住，我们在约束领域下，所以即使你__先前__不知道轮班情况，也是可行的

--------------------------------------------
post_shifts(Counts) :-
     length(UnknownShifts, 21),
     bagof(X, between(1,6,X), Keys),
     length(Values, 6),
     pairs_keys_values(Counts, Keys, Values),
     global_cardinality(UnknownShifts, Counts, []),
     % 在这一点上，我已经约束了Counts和UnknownShifts，
     % 尽管我不知道UnknownShifts
     shifts(UnknownShifts). % 现在它被绑定了
--------------------------------------------

++global_cardinality/3++有两个选项

* +consistency(value)+  -  呈现++较弱++的一致性。我不知道这意味着什么，如果你明白请告诉我。
* cost(Cost, Matrix) - 给定一个由键i在位置j的值组成的矩阵，将总价值约束为Cost

.global_cardinality练习
****************************

设计一个**练习**，该练习要用到global_cardinality的++cost/2++选项。并给出一个解。

****************************

++cumulative/2++和++cumulative/1++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

++cumulative/2++读取一个__任务__列表，并约束其在任务期间的任何时候不超过限制。

可以通过组合开始、持续和结束时间中的任意两者来灵活地指定任务。每个任务还包含其使用的资源量和一个任务标识符。

++cumulative/1++则默认限制为1。

.机械
===============

---------------------------
%
%  我们有3台机械，需要做一些维修工作
%  进行传输工作需要两台机械
%
%  为每天10小时的工作设定一组开始时间
%
task_names([
    transmission, brake_job_1, brake_job_2, diagnosis_1,
    diagnosis_2, fuel_injection]).

tasks([
    task(S1,3,_,2,1),
    task(S2,1,_,1,2),
    task(S3,1,_,1,3),
    task(S4,3,_,1,4),
    task(S5,3,_,1,5),
    task(S6,2,_,1,6)], [S1, S2, S3, S4, S5, S6]).

find_task_starts(S) :-
	length(S, 6),
	S ins 0..9,
	tasks(Tasks, S),
	cumulative(Tasks, [limit(3)]),
	label(S).

2 ?- find_task_starts(S).
S = [0, 0, 1, 2, 3, 3] ;
S = [0, 0, 1, 2, 3, 4] ;
S = [0, 0, 1, 2, 3, 5] ;
S = [0, 0, 1, 2, 3, 6] ;
S = [0, 0, 1, 2, 3, 7] .
---------------------------

===============

.cumulative练习
**********************

1)看起来机械的工作不是很充实。再添加几个任务。

2)3号机械仅在一天的前3个小时工作。修改示例，将这个要求纳入其中。

**********************

优化
--

我们经常不只满足于找到符合约束条件的解，还要找到最优解。像“工厂应该生产哪些产品来实现利润最大化？”和“有3台机械，我们能多快修好所有这些车？”这样的问题都是优化问题。

++label/1++还有一个具有两个元数的版本，名称稍有不同，即++labeling/2++。
选项是在第一个参数。这些选项对于优化问题和提升标注过程的效率都很重要。

现在我们要关注的两个参数是++max/1++和++min/1++。将其中一个放入选项中，就能按顺序显示解，最左边为最大值或最小值，然后按序向下排列。
max会按递减顺序排序，min则按递增顺序排序。

.中序遍历
-------------------------------------------------------------
7 ?- [X,Y] ins 1..3, labeling([max(X), min(Y)], [X,Y]).
X = 3,
Y = 1 ;
X = 3,
Y = 2 ;
X = Y, Y = 3 ;
X = 2,
Y = 1 ;
X = Y, Y = 2 ;
X = 2,
Y = 3 ;
X = Y, Y = 1 ;
X = 1,
Y = 2 ;
X = 1,
Y = 3 ;
false.
-------------------------------------------------------------

快速标注
----

在内部，++labeling/2++每次会尝试把值赋给变量。每次选择一个值，就会移除一个可能性子树。你要让那些子树尽可能大。

如何高效标注
~~~~~~

首先对要标注的变量进行排序。先分配最大的能削减搜索树的值。知道这些是什么取决于对域的了解，但如果有必要，你可以在使用中收集数据。

通常，你会有选择地标注变量。假设你正在使用医疗推荐系统。下面是一些项目：

* 治疗辐射照射
* 开抗生素
* 提供高压复压
* 插管以提供气道
* 开止痛药
* 开抗眼镜蛇毒的药
* 提供血压调节器

常识是，辐射照射比流鼻涕更罕见，相比__治疗辐射照射__，我们会更常匹配到__开抗生素__这个项目。因此按照这个顺序检查项目可能会更快：

* 开止痛药
* 插管以提供气道
* 提供血压调节器
* 开抗生素
* 提供高压复压
* 开抗眼镜蛇毒的药
* 治疗辐射照射

在Prolog中，它可能会是这样呈现

.更好的顺序
-----------------------------------------
treatments([painkillers,
			intubate,
			bp_regulators,
			antibiotics,
			hyperbaric_chamber,
			anti_cobra_venom,
			radiation_exposure
			]).
-----------------------------------------


设定
~~

++labeling/2++的第一个参数中有3个设定项：变量选择策略、数值顺序和分支策略。为每个设置选定一个值（或使用默认值）。

最多可以为每个类别的设定一个选项，并且选项不得重复出现。 

在某种程度上，选择最佳设定是一个实验问题。如果你感到绝望，还有一个未归纳入文档的谓词++random_value(Seed)++（感谢 https://github.com/adbenitez[adbenitez] 指出这一点）或++random_variable++。

本节的部分内容是从文档中复制过来的。


变量选择策略
^^^^^^

变量选择策略可以让你指定Vars中下一个要标注的变量，并且是其中之一：

* +leftmost+ - 按照变量在Vars中出现的顺序标注它们。这是默认设定。

* +ff+  失败优先。不断用最小的域标注最左边的变量，以便尽早发现不可行性。当选定第一个变量、后续变量的域很小时，这通常是一个很好的策略。

* +ffc+ 在域最小的变量中，标注进行最多约束的最左边的变量为下一个变量。应用一个约束条件就必须删除一个子树，所以这可能是一个好的策略。

* +min+  标注下界最小、最左边的变量为下一个变量。注意，这个是++min/0++，与++min/1++不同，后者决定解的顺序，它在上面的前一节中讨论过。如果你试图让某个总值最小，在各种变量都较小的情况下这个总值可能会更小，那么这是一个很好的策略（例如，最小成本的解决方案）。

* +max+  标注上界最大、最左边的变量为下一个变量。这也与++max/1++不同。而且，当试图使一个总值最大时，对++min++的建议也适用于++max++。

数值顺序
^^^^

数值顺序是以下之一：

* +up+ 按升序尝试所选变量域的元素。这是默认设定。

* +down+ 按降序尝试域内元素。

显然，如果元素出现的频率不均匀，就按频率由高到低的顺序尝试元素，就像我们上面在如何高效标注中展示的那样。

分支策略
^^^^

分支策略是以下之一：

* +step+ 对于每个变量X，在X = V和X #= V之间做出选择，其中V由数值顺序选项决定。这是默认设定。

* +enum+  对于每个变量 X，对于X域内所有值 V_i，在X = V_1、X = V_2等之间进行选择，顺序由价值排序选项确定。 

* +bisect+ 对于每个变量X，在X #=< M和X #> M之间进行选择，其中M是X的域的中点。如果变量是从一系列整数中选择一个值，而不是在一组枚举值中选择一个（例如百分比、vs a=0、b=1、c=2），请选择此选项。

调试和测试
-----

通过隔离程序中设置约束的部分，可以在更高层次查看受约束的域。

下面这些谓词，在调试和将clp(fd)与Prolog环境的其他部分连接起来时很有用。

+fd_var(+Var)+ 如果Var是一个CLP(FD)变量，则为真。

+fd_inf(+Var, -Inf)+   Inf是Var的当前域的下确界。

+fd_sup(+Var, -Sup)+  Sup是Var的当前域的上确界。

+fd_size(+Var, -Size)+  确定变量的域的大小。Size是Var的当前域的元素数量，如果域是无界的，则为原子sup。

+fd_dom(+Var, -Dom)+   Dom是Var的当前域。如果你想对域进行推理，这个谓词会非常有用。如果你只想显示要调试的域，请使用图形调试器或顶层。

+indomain/1+  在回溯时将其参数绑定给其域的成员。 

例如，要实现自定义标注策略，你可能需要检查有限域变量的当前域。使用以下代码，可以将有限域转换为整数列表：

.域作为整数
=================

---------------------------------------------------------------
dom_integers(D, Is) :- phrase(dom_integers_(D), Is).

dom_integers_(I)      --> { integer(I) }, [I].
dom_integers_(L..U)   --> { numlist(L, U, Is) }, Is.
dom_integers_(D1\/D2) --> dom_integers_(D1), dom_integers_(D2).
示例：

?- X in 1..5, X #\= 4, fd_dom(X, D), dom_integers(D, Is).
D = 1..3\/5,
Is = [1,2,3,5],
X in 1..3\/5.
---------------------------------------------------------------

=================

考虑使用clp(fd)来编写类似的东西。

++call_residue_vars/2++调用一个谓词，然后报告所有没有得出结果的约束或被冻结的变量。因为通常一个正确的程序会解析它所有的变量，这对于发现没有解析的东西很有用。

当心它可能有程序错误。

分阶段应用约束
-------

能够__坚持__一个约束变量的系统，应用更多，然后备份并删除后面的约束是有用的。

例如，假设你有一个基于约束的绘图程序——一个用来绘制零件的程序，如果把一个零件调整得几乎与另一个零件对齐，则该程序会__意识到__你希望它们垂直或水平对齐。如果随后拖动其中一个块，它们都会同时移动以保持约束。

要得出块的实际位置，必须将其中一个块约束到拖动到的位置，从而使所有块都约束到单个值。但这时你会丢弃所有约束！

对此有两种解决方案。第一种，回溯，可以在许多情况下使用，当然，这在程序中就必须要使用特定结构。因此，这更适合混合搜索约束策略这样的情况，在这种情况下，你可以设置了一些约束条件，然后搜索，再添加不同的约束，并在问题过约束的时候进行回溯。

第二种解决方案是++copy_term/2++。

++copy_term/2++复制一个项（通常是域变量列表），创建一个__形式__相同但却使用新变量的新项。副本包括属性（因此也包括约束）。

至于相同的__形式__，我们的意思是：

* 原子项目与相同项目匹配
* 变量与变量匹配
*  列表匹配具有相同形式的项目、相同长度的列表。
* 复合项匹配具有相同函子和实参形式的复合项。

.复制项
============

--------------------------------------------------------
10 ?- copy_term(foo([bar, A, meep(B, [1,2])], 3), Copy).
Copy = foo([bar, _G2450, meep(_G2456, [1, 2])], 3).
--------------------------------------------------------

============

那么，约束会发生什么呢？

.复制项的属性
=======================

-----------------------------------------------------------------------------
3 ?- X in 0..10, Y in 0..5, X #< Y, copy_term(foo(X,Y), foo(XA, YA)), YA = 3.
YA = 3,
X in 0..4,
X#=<Y+ -1,
Y in 1..5,
XA in 0..2.
-----------------------------------------------------------------------------

=======================

只复制一半约束变量通常不是一个好主意，最终你会得到约束系统之外的关系。这个不是严格禁止的，但除非是有特殊用意才这么做，因为通常你希望约束系统处于一个可以返回的__稳定__位置。

.复制项的一半属性
====================================================================

-----------------------------------------------------------------

5 ?- X in 0..10, Y in 0..5, X #< Y, copy_term([Y], [YA]), YA = 3.
YA = 3,
X in 0..4,
X#=<Y+ -1,
Y in 1..5.

-----------------------------------------------------------------

====================================================================

.约束图形练习
************************************************************************************************

编写一个小型图形程序，使用任意你熟悉的图形开发环境，在屏幕上绘制一组点。如果你移动其中一个点，使之与另一个几个像素内的点垂直或水平对齐，那么这两个点应该连接起来，并一起移动。
按住shift键总是只移动一个点。

额外加分
把你的程序扩展为一个小型图形编辑器。

（注意，你已经接近教程的末尾，你可能希望在解决这个问题的同时把这个教程读完）。

************************************************************************************************

.约束外壳
***********************************************************************************************
实现了一个约束外壳决策支持系统。它能让用户使用一些简单的命令语言（而不是编程）定义约束，并查看变量的域。用户应该能够删除他们引入的任何约束。 

示例运行

-----------------------------------
?-decision_support.
决策支持（键入h获取帮助）
ds=h
l = 列出所有变量和约束
<variable name> in <integer> thru <integer> = 定义一个新变量
<variable name> <operator> <integer or variable name> = 定义一个新约束
r <number>  = 撤销约束 <number>
q = quit

ds=a in 1 thru 10
a in 1..10
ds=b in 1 thru 10
b in 1..10
ds=a < b
#1: a < b
ds=b < 5
#2: b < 5
ds=l
变量   
a in 1..3
b in 1..4
约束
#1: a < b
#2: b < 5
ds=r 2
撤销 #2: b < 5
ds=b < 8
#3: b < 8
ds=l
变量
a in 1..6
b in 1..7
约束
#1: a < b
#3: b < 8
ds=q
?-

-----------------------------------

***********************************************************************************************

			
制定自己的约束
-------

首先，你通常不必创建自定义约束，只需要创建一个便利的自定义谓词。如果你需要__有些近似__这个约束条件，即约束X和Y彼此之间相距N到M个空间，那么你可以编写一个适用于所有约束的普通谓词。这就是你在本教程中一直在做的事情。

.有些近似
=================

--------------------------------------------------------
sort_of_near_to(X, Y, N, M) :-
	X #> Y #==> X - N #>= Y  #/\  X - M - 1 #< Y,
	X #=< Y #==> Y - N #>= X #/\ Y - M - 1 #< X.
--------------------------------------------------------

=================

如果你确实要编写一个约束，下面是方法。

首先，你需要进行一些设定

.自己的约束设定
======================

-----------------------------------------
:- use_module(library(clpfd)).

:- multifile clpfd:run_propagator/2.
-----------------------------------------

======================

然后，你需要定义用户用来使用你的约束的谓词。

在这个谓词中，要完成三个步骤。 

1. 通过调用++clpfd:make_propagator/2++，将约束转换为内部形式，即__传播程序__。
2. 通过调用++clpfd:init_propagator/2++，将每个变量附加到传播程序。
3. 触发传播程序以设置初始状态，如果过度约束，则失败，并使用++clpfd:trigger_once/1++设置初始域。


. 偶数谓词
====================

-------------------------------------------------------
% 将X约束为偶数
even(X) :-
        clpfd:make_propagator(even(X), Prop),  <1>
        clpfd:init_propagator(X, Prop),  <2>
        clpfd:trigger_once(Prop). <3>
-------------------------------------------------------

<1> 将这个约束转化为内部形式++Prop++，即__传播程序__。
<2> 将每个变量（这里只有X）附加到内部传播程序。
<3> 触发一次传播程序，将初始状态添加到系统中。

====================

最后，需要定义在计算约束时调用的条件检查。这需要向++clpfd:run_propagator/2++添加一个子句。

++clpfd:run_propagator/2++中的第一个参数必须与++make_propagator/2++中的声明相匹配。 

第二个参数是由clp(fd)维护的可变状态。如果不再需要触发约束、如果约束失败或变量绑定为一个有效值，或者现在它的域被削减到只剩能满足约束的值，则可以使用它来__杀死__约束。

.偶数回调
====================

----------------------------------------------------------------
% 将X约束为偶数
clpfd:run_propagator(even(X), MState) :-
        (   integer(X) -> clpfd:kill(MState), 0 is X mod 2
        ;   true
        ).
----------------------------------------------------------------

====================

现在可以使用我们的新约束了。

.新约束
====================

---------------------------------
[debug] 26 ?- even(1).
false.

[debug] 27 ?- even(2).
true.

[debug] 28 ?- even(X),X = 2.
X = 2.

[debug] 29 ?- even(X),X = 3.
false.
---------------------------------

====================

注意，run_propagator是不确定的。它可能会失败（这表明X没有解决方案）。例如，even(X),X = 3.

.尝试偶数练习
*************************

在++clpfd:run_propagator/2++放置一个监视点，并查询even(X), X = 3.

看看run_propagator被调用了多少次？

*************************

[TIP]
有趣的事实——Julian库大量使用了clp(fd)。

结语
--

请记住，只要你有多个变量，并且需要在所有变量之间求出一个相容的解，你就应该考虑约束编程。

SWI-Prolog附带了许多约束库。如果你真的受到了启发，可以为clp(b)、clp(qr)或CHR做一个与本篇教程类似的教程。如果你有想法这么做，请给我写信，因为我们正试图把这些教程整合在一个很好的库中，并使用一种通用的格式，这样我们就可以自动处理下游的部分流程。

希望你喜欢这个教程。如果你注意到任何错误，或是想提出改进建议，或者完全被难住了，请发送电子邮件至 annie66us@yahoo.com，让我知道。

你通常可以在freenode.net IRC的##prolog频道里找到我，我是Anniepoo。

感谢马库斯·特里斯卡的clp(fd)库。向马库斯致意！感谢艾伦·波尤解决了一些令人困惑的问题。感谢迈克尔·里克特提供的生成教程所需的软件管道的配置。
